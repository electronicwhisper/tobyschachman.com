// Generated by CoffeeScript 1.6.3
(function() {
  var animationLoop, bigDistance, draw, drawCartesian, drawPolar, gridDistance, mousePosition, n, resizeCanvas;

  bigDistance = 3000;

  gridDistance = 100;

  n = numeric;

  mousePosition = [0, 0];

  document.addEventListener("mousemove", function(e) {
    return mousePosition = [e.clientX, e.clientY];
  });

  animationLoop = function() {
    requestAnimationFrame(animationLoop);
    resizeCanvas();
    return draw();
  };

  requestAnimationFrame(animationLoop);

  resizeCanvas = function() {
    var canvasEl, rect;
    canvasEl = document.getElementById("c");
    rect = canvasEl.getBoundingClientRect();
    canvasEl.width = rect.width;
    return canvasEl.height = rect.height;
  };

  draw = function() {
    var canvasEl, center, ctx, rect;
    canvasEl = document.getElementById("c");
    ctx = canvasEl.getContext("2d");
    rect = canvasEl.getBoundingClientRect();
    center = [rect.width / 2, rect.height / 2];
    ctx.strokeStyle = "#ccc";
    drawPolar(ctx, center, [1, 0]);
    ctx.strokeStyle = "#7ca";
    return drawCartesian(ctx, mousePosition, n.sub(mousePosition, center));
  };

  drawPolar = function(ctx, center, axisVector) {
    var distance, i, spokes, _i, _j, _ref;
    ctx.save();
    ctx.translate.apply(ctx, center);
    ctx.rotate(Math.atan2(axisVector[1], axisVector[0]));
    spokes = 24;
    for (i = _i = 0; 0 <= spokes ? _i < spokes : _i > spokes; i = 0 <= spokes ? ++_i : --_i) {
      ctx.save();
      ctx.rotate(2 * Math.PI * i / spokes);
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.lineTo(bigDistance, 0);
      ctx.globalAlpha = i === 0 ? 1 : 0.2;
      ctx.stroke();
      ctx.restore();
    }
    for (i = _j = 0, _ref = bigDistance / gridDistance; 0 <= _ref ? _j < _ref : _j > _ref; i = 0 <= _ref ? ++_j : --_j) {
      distance = gridDistance * i;
      ctx.beginPath();
      ctx.arc(0, 0, distance, 0, 2 * Math.PI, false);
      ctx.globalAlpha = 0.2;
      ctx.stroke();
    }
    return ctx.restore();
  };

  drawCartesian = function(ctx, center, axisVector) {
    var drawGridLine, end, i, start, x, y, _i, _j, _ref, _ref1, _ref2, _ref3;
    ctx.save();
    ctx.translate.apply(ctx, center);
    ctx.rotate(Math.atan2(axisVector[1], axisVector[0]));
    drawGridLine = function(start, end, strong) {
      ctx.beginPath();
      ctx.moveTo.apply(ctx, start);
      ctx.lineTo.apply(ctx, end);
      ctx.globalAlpha = strong ? 1 : 0.2;
      return ctx.stroke();
    };
    for (i = _i = _ref = -bigDistance / gridDistance, _ref1 = bigDistance / gridDistance; _ref <= _ref1 ? _i < _ref1 : _i > _ref1; i = _ref <= _ref1 ? ++_i : --_i) {
      x = i * gridDistance;
      start = [x, -bigDistance];
      end = [x, bigDistance];
      drawGridLine(start, end, x === 0);
    }
    for (i = _j = _ref2 = -bigDistance / gridDistance, _ref3 = bigDistance / gridDistance; _ref2 <= _ref3 ? _j < _ref3 : _j > _ref3; i = _ref2 <= _ref3 ? ++_j : --_j) {
      y = i * gridDistance;
      start = [-bigDistance, y];
      end = [bigDistance, y];
      drawGridLine(start, end, y === 0);
    }
    return ctx.restore();
  };

}).call(this);
